<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Final</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"/>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet"/>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      @font-face {
        font-family: 'Trajan';
        src: url('./fonts/TrajanProRegular.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }

      .title {
        position: absolute;
        top: 10px;
        left: 10px;
        font-family: 'Trajan', Arial, sans-serif;
        color: #66023C;
        font-size: 50px;
        border-radius: 5px;
        width: auto;
        line-height: 60px;
        text-align: center;
      }

      .mapboxgl-popup-close-button {
        color: #66023C;
        font-size: 20px;
      }
      .mapboxgl-popup-content {
        min-width: 300px;
        align-self: center;
      }
      #search {
        position: absolute;
      }

    </style>
  </head>
  <body>
    
    <div id="map"></div>

    <script>
      function convertToRoman(num) {
        var romanMatrix = [
        [1000, 'M'],
        [900, 'CM'],
        [500, 'D'],
        [400, 'CD'],
        [100, 'C'],
        [90, 'XC'],
        [50, 'L'],
        [40, 'XL'],
        [10, 'X'],
        [9, 'IX'],
        [5, 'V'],
        [4, 'IV'],
        [1, 'I']];

        for (let i in romanMatrix) {
          if (num >= romanMatrix[i][0]) {
            return romanMatrix[i][1] + convertToRoman(num - romanMatrix[i][0]);
          }
        }
      }

      mapboxgl.accessToken =
        "pk.eyJ1IjoiZGJsaXNhcmQiLCJhIjoiY2xnNWQ2NzBqMDFvMTNtbWpjcnF2N3BwayJ9.A_cJHb58qSAoYjKyBcz6yw";
      const map = new mapboxgl.Map({
        container: "map",
        // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
        style: "mapbox://styles/dblisard/clhh3kx1s002m01r5445thn5d",
        maxBounds: [
          [-10, 27], // Southwest coordinates [longitude, latitude]
          [40, 50]   // Northeast coordinates [longitude, latitude]
        ],
        center: [16.633617, 38.408870],
        zoom: 2,
        minZoom: 4,
        pitchWithRotate: false, // Disable 3D mode
        dragRotate: false // Disable map rotation
      });

      map.on("load", () => {
        map.addSource("shipwrecks", {
          type: "geojson",
          data: "Shipwrecks.geojson",
          cluster: true,
          clusterMaxZoom: 14, // Max zoom to cluster points on
          clusterRadius: 25, // Radius of each cluster when clustering points
        });

        map.addLayer({
          id: "clusters",
          type: "circle",
          source: "shipwrecks",
          filter: ["has", "point_count"],
          paint: {
            "circle-color": "#66023C",
            "circle-radius": [
              "step",
              ["get", "point_count"],
              10,
              10,
              15,
              15,
              20,
            ],
            "circle-stroke-width": 2,
            "circle-stroke-color": "#ffffff",
          },
        });

        map.addLayer({
          id: "cluster-count",
          type: "symbol",
          source: "shipwrecks",
          filter: ["has", "point_count"],
          layout: {
            "text-field": ["get", "point_count"],
            "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
            "text-size": 16,
          },
          paint: {"text-color": "#fff"}
        });


        map.addLayer({
          id: "unclustered-point",
          type: "circle",
          source: "shipwrecks",
          filter: ["!", ["has", "point_count"]],
          paint: {
            "circle-color": "#66023C",
            "circle-radius": 5,
            "circle-stroke-width": 2,
            "circle-stroke-color": "#ffffff",
          },
        });

        // Create a geographically static HTML marker
        //const markerElement = document.createElement('div');
        //markerElement.className = 'title';
        //markerElement.innerHTML = 'Ancient Shipwrecks<br>of the<br>mediterranean';

        //new mapboxgl.Marker(markerElement)
        //  .setLngLat([22, 46.25])
        //  .addTo(map);


        // inspect a cluster on click
        map.on("click", "clusters", (e) => {
          const features = map.queryRenderedFeatures(e.point, {
            layers: ["clusters"],
          });
          const clusterId = features[0].properties.cluster_id;
          map
            .getSource("shipwrecks")
            .getClusterExpansionZoom(clusterId, (err, zoom) => {
              if (err) return;

              map.easeTo({
                center: features[0].geometry.coordinates,
                zoom: zoom,
              });
            });
        });

        // When a click event occurs on a feature in
        // the unclustered-point layer, open a popup at
        // the location of the feature, with
        // description HTML from its properties.
        map.on("click", "unclustered-point", (e) => {
          let coordinates = e.features[0].geometry.coordinates.slice();
          let name = e.features[0].properties.Name || "N/A";
          let cargo = e.features[0].properties["Other cargo"];
          let comments = e.features[0].properties.Comments;
          let period = e.features[0].properties.Period || "N/A";
          let dating = e.features[0].properties.Dating || "N/A";
          let firstdate = e.features[0].properties["Earliest date"];
          let lastdate = e.features[0].properties["Latest date"];
          let depth = e.features[0].properties.Depth || "N/A";


          if (comments == "") {
            if(cargo == ""){
              comments = "No Details";
            }
          }

          if (firstdate < 0) {
            firstdate = firstdate.slice(1) + " BCE"
          } else {
            firstdate = firstdate + " CE"
          }          
          if (lastdate < 0) {
            lastdate = lastdate.slice(1) + " BCE"
          } else {
            lastdate = lastdate + " CE"
          }

          // Ensure that if the map is zoomed out such that
          // multiple copies of the feature are visible, the
          // popup appears over the copy being pointed to.
          while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
            coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
          }

          new mapboxgl.Popup()
            .setLngLat(coordinates)
            .setHTML(`<b>${name} Wreck</b><br>
                      Period: ${period}<br> 
                      Dating: ${firstdate} to ${lastdate}<br>
                      Depth: ${depth}<br>
                      <hr>
                      ${comments} ${cargo}`)
            .addTo(map);
        });

        map.on("mouseenter", "clusters", () => {
          map.getCanvas().style.cursor = "pointer";
        });
        map.on("mouseleave", "clusters", () => {
          map.getCanvas().style.cursor = "";
        });
        map.on("mouseenter", "unclustered-point", () => {
          map.getCanvas().style.cursor = "pointer";
        });
        map.on("mouseleave", "unclustered-point", () => {
          map.getCanvas().style.cursor = "";
        });
      });
    </script>
  </body>
</html>
